# Web Generative UI

A frontend library for creating dynamic, AI-driven web interfaces that adapt in real-time, specifically designed for applications leveraging large language models (LLMs) and protocols like the Model Context Protocol (MCP).

[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)

## Introduction

**Web Generative UI** is a robust frontend library engineered to build dynamic, AI-powered user interfaces. Drawing inspiration from advanced conversational AI paradigms, particularly the **Model Context Protocol (MCP)**, it empowers developers to craft web experiences where content and UI elements are generated and adapted in real-time. This enables unparalleled interactivity, personalization, and responsiveness.

Whether you're developing sophisticated conversational agents, adaptive dashboards, personalized e-commerce interfaces, or cutting-edge web applications, Web Generative UI provides the foundational tools to create intelligent, engaging, and highly adaptive user experiences. We believe this approach represents the future of user interfaces, extending beyond just web applications to encompass other platforms.

## Features

-   **Dynamic UI Rendering**: Renders user interfaces that adapt and update in real-time, responding instantly to AI-driven instructions and data.
-   **LLM-Driven by Design**: Built from the ground up to consume and display content generated by Large Language Models, central to an "AI-first" application development approach.
-   **Enables AI-Driven Content**: Provides the infrastructure to seamlessly integrate and display dynamically generated content, fostering highly personalized user interactions.
-   **Comprehensive Context Management**: Manages conversation history and state through a `ConversationStore`, featuring in-memory caching for performance and optional pluggable persistence (e.g., `LocalStoragePersistence`) for data longevity.
-   **Optimized for Model Context Protocol (MCP)**: Specifically designed to provide the necessary frontend infrastructure for applications built on the Model Context Protocol, facilitating structured communication with AI models.
-   **Real-Time Adaptability**: Utilizes a sophisticated `Interpreter` to efficiently reconcile and update UI components on the fly, minimizing page reloads and ensuring a fluid user experience.
-   **Robust Transport Channel Support**: Currently provides resilient transport layers for `Server-Sent Events (SSE)` and `WebSockets`, both incorporating **automatic reconnection strategies** with exponential backoff and jitter for stable communication.
-   **Flexible Message Handling**: Intelligently processes incoming data by converting plain text messages or schema-based content into dynamic UI patches, allowing for the creation and modification of rich UI components.
-   **Structured Conversation UI**: Automatically organizes conversation turns by creating and managing dedicated UI containers (e.g., `UiBox` elements) within the DOM, ensuring clear visual separation and targeted UI updates.
-   **Event-Driven Architecture**: Exposes an internal event system (via `on` / `off` methods) allowing components to react to crucial transport lifecycle events (e.g., `open`, `close`, `reconnect`) and conversation updates.
-   **Developer-Friendly API**: Offers simple and intuitive APIs for integrating generative UI capabilities into new or existing web projects.
-   **Cross-Platform Compatibility**: Leverages native Web Components, ensuring broad compatibility and seamless integration with modern frontend frameworks such as React, Vue, and Angular.

## Next Goals
-   [ ] Refine Component styling & theming to match the design system.
-   [ ] Introduce more flexible layout mechanisms (beyond `applyLayoutMeta`).
-   [ ] Implement a broader range of UI components.
-   [ ] Enhance Accessibility features across components and the core library.
-   [ ] Implement a robust Actions handler for interactive UI elements.
-   [ ] Support for additional transport channels (e.g., WebRTC, WebTransport).

## Usage Examples

### Setup
First, ensure you have a container element in your HTML:

```html
<button id="trigger">SEND MESSAGE</button>
<div id="container"></div>
```

### Initializing GenerativeUI with WebSocket and History Context
This example demonstrates initializing `GenerativeUI` with a WebSocket transport, enabling conversation history management, and setting up various event listeners for real-time interaction feedback.

```javascript
import GenerativeUI from "./index"; // Adjust path if using a packaged library

// Initialize GenerativeUI with a WebSocket transport and enhanced history context
const ui = await GenerativeUI.init({
    container: "#container", // Required: CSS selector or HTMLElement for UI rendering
    transport: {
        type: "websocket",
        url: "ws://localhost:3000/ws", // Your WebSocket backend URL
    },
    // enableLocalPersistence: true, // Optional: Enable localStorage for conversation history
});

// For WebSockets, explicitly connect to establish the persistent connection.
// For SSE, `connect()` is also available but often `sendMessage` will implicitly open the stream.
await ui.connect();

// Create a new conversation or retrieve an existing one
const conversationId = await ui.createConversation();
console.log("Started conversation:", conversationId);

// Main trigger for sending messages (e.g., a button click)
const trigger = document.getElementById("trigger");
trigger?.addEventListener("click", async () => {
    // sendMessage accepts either a string or an object with message content
    await ui.sendMessage(conversationId, "Call to get some fancy data");
    // Example with structured content:
    // await ui.sendMessage(conversationId, { command: "fetch_data", params: { type: "fancy" } });
});

// --- Enhanced Event Handlers ---
// You can subscribe to various transport events to react to real-time updates

// Listen for incoming messages from the AI/backend
ui.onMessage((envelope) => {
    console.log("[GenerativeUI:onMessage]", envelope);
    if (envelope.payload?.role === "assistant") {
        console.log("🤖 Assistant replied:", envelope.payload.content);
        // Additional logic like showing a desktop notification could go here
    }
});

// Listen for UI patches (direct updates to components)
ui.onPatch((patch) => {
    console.log("[GenerativeUI:onPatch]", patch);
    // Example: Trigger specific animations or UI changes based on patch type
    if (patch.type === "component_update") {
        console.log("🔄 Component updated with ID:", patch.targetId);
    }
});

// Listen for control messages (e.g., typing indicators, lifecycle events)
ui.onControl((control) => {
    console.log("[GenerativeUI:onControl]", control);
    if (control.type === "typing_start") {
        console.log("⌨️ Assistant is typing...");
    } else if (control.type === "typing_end") {
        console.log("✅ Assistant finished typing");
    }
});

// Listen for generic transport events (open, close, error, reconnect, disconnect)
ui.onEvent((event) => {
    console.log("[GenerativeUI:onEvent]", event.type, event);
});


// --- Conversation History API ---
// Retrieve conversation history programmatically
async function fetchAndDisplayHistory(convId: string) {
    const allMessages = await ui.getConversationHistory(convId);
    console.log("Full history:", allMessages);

    const recentMessages = await ui.getRecentMessages(convId, 3);
    console.log("Last 3 messages:", ui.extractMessageContent(recentMessages)); // Helper to get just content

    const messagesFromTurn = await ui.getMessagesFrom(convId, allMessages[0]?.turnId); // Example: from first turn
    console.log("Messages from first turn onwards:", messagesFromTurn);

    const lastUserContext = await ui.getLastUserContext(convId);
    console.log("Last user context:", lastUserContext);
}
// Call this function when needed, e.g., after loading an old conversation
// fetchAndDisplayHistory(conversationId);


// --- Cleanup and Error Handling ---

// Generic error handling for the transport layer
ui.onError((error, code) => {
    console.error("❌ GenerativeUI Transport Error:", error, "Code:", code);
    // You might want to display a user-facing error message in the UI
});

// Ensure the connection is gracefully closed when the user navigates away or closes the tab.
window.addEventListener("beforeunload", () => {
    console.log("🔌 Disconnecting GenerativeUI...");
    ui.disconnect();
});
```

### Example 2: Simple SSE Integration
This example shows a more minimalistic setup using Server-Sent Events.

```javascript
import GenerativeUI from "./index"; // Adjust path if using a packaged library

const ui = await GenerativeUI.init({
    container: '#container',
    transport: {
        type: 'sse',
        streamURL: 'http://localhost:3000/api/llm-stream', // SSE endpoint for receiving
        sendURL: 'http://localhost:3000/api/llm-message',   // HTTP POST endpoint for sending messages
    },
});

// Explicitly connect the transport. For SSE, `sendMessage` would also trigger connection.
await ui.connect();

const conversationId = await ui.createConversation();
console.log("SSE Conversation ID:", conversationId);

const trigger = document.getElementById('trigger');
trigger?.addEventListener('click', async () => {
    await ui.sendMessage(conversationId, 'Summarize the latest news.');
});

// Listen for basic messages
ui.onMessage((envelope) => {
    console.log("SSE Received message:", envelope.payload.content);
});

// Ensure cleanup on page unload
window.addEventListener('beforeunload', () => {
    ui.disconnect();
});
```

## Contributing
We welcome contributions to Web Generative UI! To get started:
1.  Fork the repository.
2.  Create a new branch (`git checkout -b feature/your-feature`).
3.  Make your changes and commit them (`git commit -m 'Add your feature'`).
4.  Push to your branch (`git push origin feature/your-feature`).
5.  Open a pull request.

Please read our [Contributing Guidelines](CONTRIBUTING.md) for more details and follow our [Code of Conduct](CODE_OF_CONDUCT.md).

## License
This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Community and Support
-   **Issues**: Report bugs or request features on our [GitHub Issues](https://github.com/Piplip/web-generative-ui) page.

## Acknowledgments
-   Inspired by the [Model Context Protocol](https://modelcontextprotocol.io/) technology

---
